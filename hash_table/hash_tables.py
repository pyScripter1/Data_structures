# Хэш-таблица — это структура данных, разработанная для быстрой работы.
#
# Причина, по которой хэш-таблицы иногда предпочитают массивам или связанным спискам, заключается в том, что поиск,
# добавление и удаление данных можно выполнять очень быстро, даже для больших объемов данных.
#
# В связанном списке поиск человека по имени «Боб» занимает время,
# поскольку нам пришлось бы переходить от одного узла к другому, проверяя каждый узел,
# пока не будет найден узел с именем «Боб».
#
# Поиск «Боба» в списке/массиве мог бы быть быстрым, если бы мы знали индекс,
# но когда мы знаем только имя «Боб», нам нужно сравнивать каждый элемент, а это занимает время.
#
# Однако с помощью хэш-таблицы поиск «Боба» выполняется очень быстро,
# поскольку есть способ перейти непосредственно к месту хранения «Боба», используя так называемую хэш-функцию.


# создание хэш-таблицы с нуля, нам нужно будет 5 шагов:
# создать пустой список
# Создайте хеш-функцию.
# Вставка элемента с использованием хэш-функции.
# Поиск элемента с помощью хэш-функции.
# Устранение столкновений.

# создадим список из 10 пустых элементов
my_list = [None, None, None, None, None, None, None, None, None, None]

# Теперь поговорим об особом способе взаимодействия с хэш-таблицами.
#
# Мы хотим сохранить имя непосредственно в нужном месте массива, и здесь на помощь приходит хэш-функция .
#
# Хэш-функцию можно создать многими способами, это зависит от создателя хэш-таблицы.
# Распространенный способ — найти способ преобразовать значение в число,
# равное одному из индексов хэш-таблицы, в данном случае — числу от 0 до 9.
#
# В нашем примере мы будем использовать номер Unicode каждого символа,
# суммировать их и выполнить операцию по модулю 10, чтобы получить индексные номера 0-9.

def hash_func(value):
    sum_of_chars = 0
    for char in value:
        sum_of_chars += ord(char)
    return sum_of_chars % 10 # Число, возвращаемое хэш-функцией, называется хэш-кодом .

print("'Bob' has hash-code =", hash_func("Bob"))

# Согласно нашей хеш-функции, «Боб» должен храниться по индексу 5.
#
# Давайте создадим функцию, которая добавляет элементы в нашу хеш-таблицу:
def add(name):
    index = hash_func(name)
    my_list[index] = name


# Теперь, когда у нас есть очень простая хэш-таблица,
# давайте посмотрим, как можно найти в ней имя.
#
# Чтобы найти "Пита" в хэш-таблице, мы даем имя "Пит" нашей хэш-функции.
# Хэш-функция возвращает 8, что означает, что "Пит" хранится в индексе 8.
def contains(name):
    index = hash_func(name)
    return my_list[index] == name


add("Bob")
print(my_list)
add('Pete')
add('Jones')
add('Lisa')
add('Siri')
print(my_list)
print(f"Pete contains in hash-table: {contains("Pete")}")
print(f"Pete contains in hash-table: {contains("Masha")}")


# Давайте также добавим «Стюарт» в нашу хэш-таблицу.
#
# Мы передаем «Стюарт» нашей хэш-функции, которая возвращает 3, что означает, что «Стюарт» следует сохранить по индексу 3.
#
# Попытка сохранить «Стюарт» в индексе 3 создает так называемую коллизию , поскольку «Лиза» уже сохранена в индексе 3.
#
# Чтобы исправить столкновение, мы можем освободить место для большего количества элементов в том же ведре.
# Решение проблемы столкновения таким образом называется цепочкой и
# означает освобождение места для большего количества элементов в том же ведре.
#
# Начните с создания нового списка того же размера, что и исходный список, но с пустыми блоками:

new_list = [
  [],
  [],
  [],
  [],
  [],
  [],
  [],
  [],
  [],
  []
]

# Перепишите add()функцию и добавьте те же имена, что и раньше:
def add_new(name):
    index = hash_func(name)
    new_list[index].append(name)


# Хэш-таблицы отлично подходят для:
#
# Проверка наличия чего-либо в коллекции (например, поиск книги в библиотеке).
# Хранение уникальных предметов и быстрый их поиск (например, хранение номеров телефонов).
# Связывание значений с ключами (например, связывание имен с номерами телефонов).
# Самая важная причина, по которой хэш-таблицы отлично подходят для этих целей, заключается в том,
# что хэш-таблицы очень быстры по сравнению с массивами и связанными списками, особенно для больших наборов. Массивы и связанные списки имеют временную сложность O(n)для поиска и удаления,
# тогда как хэш-таблицы имеют только O(1)среднюю.

# Сводка хэш-таблиц
# Элементы хэш-таблицы хранятся в контейнерах хранения, называемых сегментами .
#
# Хэш -функция использует ключ элемента для генерации хэш-кода .
#
# Хэш-код сообщает, к какому сегменту принадлежит элемент, поэтому теперь мы можем перейти непосредственно к этому элементу хэш-таблицы:
# изменить его, удалить или просто проверить, существует ли он.
#
# Коллизия происходит , когда два элемента хэш-таблицы имеют одинаковый хэш-код, поскольку это означает,
# что они принадлежат одному и тому же контейнеру .
#
# Коллизию можно устранить путем объединения в цепочку с использованием списков,
# что позволяет разместить более одного элемента в одном контейнере.



