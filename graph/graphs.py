# Граф — это нелинейная структура данных, состоящая из вершин (узлов) и ребер.

# Вершина, также называемая узлом, представляет собой точку или объект в графе, а ребро используется для соединения двух вершин друг с другом.
#
# Графы нелинейны, поскольку структура данных позволяет нам использовать разные пути для перехода от одной вершины к другой, в отличие от линейных структур данных, таких как массивы или связанные списки.
#
# Графы используются для представления и решения задач, где данные состоят из объектов и связей между ними, например:
#
# Социальные сети: Каждый человек — это вершина, а отношения (например, дружба) — это ребра. Алгоритмы могут подсказывать потенциальных друзей.
# Карты и навигация: местоположения, такие как город или автобусные остановки, хранятся как вершины, а дороги хранятся как ребра. Алгоритмы могут находить кратчайший маршрут между двумя местоположениями, если они хранятся как граф.
# Интернет: можно представить в виде графа, в котором веб-страницы являются вершинами, а гиперссылки — ребрами.
# Биология: графы могут моделировать такие системы, как нейронные сети или распространение заболеваний.

# Представление графа показывает, как граф хранится в памяти.
#
# Различные представления графа могут:
#
# занимают больше или меньше места.
# быстрее или медленнее производить поиск или манипулировать.
# лучше всего подходит в зависимости от того, какой тип графика у нас есть (взвешенный, направленный и т. д.), и что мы хотим делать с этим графиком.
# быть более простыми для понимания и реализации, чем другие.
# Ниже приведены краткие введения в различные представления графов, но в дальнейшем в этом руководстве мы будем использовать для графов матрицу смежности, поскольку ее легко понять и реализовать, и она работает во всех случаях, имеющих отношение к этому руководству.
#
# Представления графа хранят информацию о том, какие вершины являются смежными, и как расположены ребра между вершинами. Представления графа немного отличаются, если ребра направлены или взвешены.
#
# Две вершины являются смежными или соседними, если между ними есть ребро.


# Граф представляется как словарь, где ключи — вершины, а значения — списки смежных вершин.
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}

print(graph)  # {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}

# Граф представляется в виде матрицы, где matrix[i][j] = 1, если есть ребро между вершинами i и j, иначе 0.
# Граф из 4 вершин (A=0, B=1, C=2, D=3)
adj_matrix = [
    [0, 1, 1, 0],  # A -> B, C
    [1, 0, 0, 1],  # B -> A, D
    [1, 0, 0, 1],  # C -> A, D
    [0, 1, 1, 0]   # D -> B, C
]

print(adj_matrix)  # [[0, 1, 1, 0], [1, 0, 0, 1], [1, 0, 0, 1], [0, 1, 1, 0]]


# Граф хранится как список списков (или словарь списков).
# Вариант 1: Список списков (вершины — числа)
adj_list = [
    [1, 2],  # 0 (A) -> 1 (B), 2 (C)
    [0, 3],  # 1 (B) -> 0 (A), 3 (D)
    [0, 3],  # 2 (C) -> 0 (A), 3 (D)
    [1, 2]   # 3 (D) -> 1 (B), 2 (C)
]

# Вариант 2: Словарь списков (вершины — любые хешируемые объекты)
adj_list_dict = {
    'A': ['B', 'C'],
    'B': ['A', 'D'],
    'C': ['A', 'D'],
    'D': ['B', 'C']
}

print(adj_list_dict)  # {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}



# Граф представляется как объект с вершинами и рёбрами.
class Graph:
    def __init__(self):
        self.vertices = {}

    def add_vertex(self, vertex):
        if vertex not in self.vertices:
            self.vertices[vertex] = []

    def add_edge(self, v1, v2):
        if v1 in self.vertices and v2 in self.vertices:
            self.vertices[v1].append(v2)
            self.vertices[v2].append(v1)  # Для неориентированного графа

    def __str__(self):
        return str(self.vertices)


# Пример использования
g = Graph()
g.add_vertex('A')
g.add_vertex('B')
g.add_vertex('C')
g.add_vertex('D')
g.add_edge('A', 'B')
g.add_edge('A', 'C')
g.add_edge('B', 'D')
g.add_edge('C', 'D')

print(g)  # {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'D'], 'D': ['B', 'C']}









